<?php
/**
 * QueryApi
 * PHP version 5
 *
 * @category Class
 * @package  Swagger\Client
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * Looker API 3.1 Reference
 *
 * ### Authorization  The Looker API uses Looker **API3** credentials for authorization and access control. Looker admins can create API3 credentials on Looker's **Admin/Users** page. Pass API3 credentials to the **_/login** endpoint to obtain a temporary access_token. Include that access_token in the Authorization header of Looker API requests. For details, see [Looker API Authorization](https://looker.com/docs/r/api/authorization)  ### Client SDKs  The Looker API is a RESTful system that should be usable by any programming language capable of making HTTPS requests. Client SDKs for a variety of programming languages can be generated from the Looker API's Swagger JSON metadata to streamline use of the Looker API in your applications. A client SDK for Ruby is available as an example. For more information, see [Looker API Client SDKs](https://looker.com/docs/r/api/client_sdks)  ### Try It Out!  The 'api-docs' page served by the Looker instance includes 'Try It Out!' buttons for each API method. After logging in with API3 credentials, you can use the \"Try It Out!\" buttons to call the API directly from the documentation page to interactively explore API features and responses.  Note! With great power comes great responsibility: The \"Try It Out!\" button makes API calls to your live Looker instance. Be especially careful with destructive API operations such as `delete_user` or similar. There is no \"undo\" for API operations.  ### Versioning  Future releases of Looker will expand this API release-by-release to securely expose more and more of the core power of Looker to API client applications. API endpoints marked as \"beta\" may receive breaking changes without warning (but we will try to avoid doing that). Stable (non-beta) API endpoints should not receive breaking changes in future releases. For more information, see [Looker API Versioning](https://looker.com/docs/r/api/versioning)  ### In This Release  This **API 3.1** is in active development. This is where support for new Looker features will appear as non-breaking additions - new functions, new optional parameters on existing functions, or new optional properties in existing types. Additive changes should not impact your existing application code that calls the Looker API. Your existing application code will not be aware of any new Looker API functionality until you choose to upgrade your app to use a newer Looker API client SDK release.  The following are a few examples of noteworthy items that have changed between API 3.0 and API 3.1. For more comprehensive coverage of API changes, please see the release notes for your Looker release.  ### Examples of new things added in API 3.1 (compared to API 3.0):  * [Dashboard construction](#!/3.1/Dashboard/) APIs * [Themes](#!/3.1/Theme/) and [custom color collections](#!/3.1/ColorCollection) APIs * Create and run [SQL Runner](#!/3.1/Query/run_sql_query) queries * Create and run [merged results](#!/3.1/Query/create_merge_query) queries * Create and modify [dashboard filters](#!/3.1/Dashboard/create_dashboard_filter) * Create and modify [password requirements](#!/3.1/Auth/password_config)  ### Deprecated in API 3.0  The following functions and properties have been deprecated in API 3.0.  They continue to exist and work in API 3.0 for the next several Looker releases but they have not been carried forward to API 3.1:  * Dashboard Prefetch functions * User access_filter functions * User API 1.0 credentials functions * Space.is_root and Space.is_user_root properties. Use Space.is_shared_root and Space.is_users_root instead.  ### Semantic changes in API 3.1:  * [all_looks()](#!/3.1/Look/all_looks) no longer includes soft-deleted looks, matching [all_dashboards()](#!/3.1/Dashboard/all_dashboards) behavior. You can find soft-deleted looks using [search_looks()](#!/3.1/Look/search_looks) with the `deleted` param set to True. * [all_spaces()](#!/3.1/Space/all_spaces) no longer includes duplicate items * [search_users()](#!/3.1/User/search_users) no longer accepts Y,y,1,0,N,n for Boolean params, only \"true\" and \"false\". * For greater client and network compatibility, [render_task_results](#!/3.1/RenderTask/render_task_results) now returns HTTP status **202 Accepted** instead of HTTP status **102 Processing** * [all_running_queries()](#!/3.1/Query/all_running_queries) and [kill_query](#!/3.1/Query/kill_query) functions have moved into the [Query](#!/3.1/Query/) function group.   If you have application code which relies on the old behavior of the APIs above, you may continue using the API 3.0 functions in this Looker release. We strongly suggest you update your code to use API 3.1 analogs as soon as possible.
 *
 * OpenAPI spec version: 3.1.0
 * Contact: support@looker.com
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 * Swagger Codegen version: 2.4.8
 */

/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace Swagger\Client\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use Swagger\Client\ApiException;
use Swagger\Client\Configuration;
use Swagger\Client\HeaderSelector;
use Swagger\Client\ObjectSerializer;

/**
 * QueryApi Class Doc Comment
 *
 * @category Class
 * @package  Swagger\Client
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class QueryApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation allRunningQueries
     *
     * Get All Running Queries
     *
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\RunningQueries[]
     */
    public function allRunningQueries()
    {
        list($response) = $this->allRunningQueriesWithHttpInfo();
        return $response;
    }

    /**
     * Operation allRunningQueriesWithHttpInfo
     *
     * Get All Running Queries
     *
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\RunningQueries[], HTTP status code, HTTP response headers (array of strings)
     */
    public function allRunningQueriesWithHttpInfo()
    {
        $returnType = '\Swagger\Client\Model\RunningQueries[]';
        $request = $this->allRunningQueriesRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\RunningQueries[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation allRunningQueriesAsync
     *
     * Get All Running Queries
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function allRunningQueriesAsync()
    {
        return $this->allRunningQueriesAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation allRunningQueriesAsyncWithHttpInfo
     *
     * Get All Running Queries
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function allRunningQueriesAsyncWithHttpInfo()
    {
        $returnType = '\Swagger\Client\Model\RunningQueries[]';
        $request = $this->allRunningQueriesRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'allRunningQueries'
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function allRunningQueriesRequest()
    {

        $resourcePath = '/running_queries';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createMergeQuery
     *
     * Create Merge Query
     *
     * @param  \Swagger\Client\Model\MergeQuery $body Merge Query (optional)
     * @param  string $fields Requested fields (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\MergeQuery
     */
    public function createMergeQuery($body = null, $fields = null)
    {
        list($response) = $this->createMergeQueryWithHttpInfo($body, $fields);
        return $response;
    }

    /**
     * Operation createMergeQueryWithHttpInfo
     *
     * Create Merge Query
     *
     * @param  \Swagger\Client\Model\MergeQuery $body Merge Query (optional)
     * @param  string $fields Requested fields (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\MergeQuery, HTTP status code, HTTP response headers (array of strings)
     */
    public function createMergeQueryWithHttpInfo($body = null, $fields = null)
    {
        $returnType = '\Swagger\Client\Model\MergeQuery';
        $request = $this->createMergeQueryRequest($body, $fields);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\MergeQuery',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 409:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ValidationError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createMergeQueryAsync
     *
     * Create Merge Query
     *
     * @param  \Swagger\Client\Model\MergeQuery $body Merge Query (optional)
     * @param  string $fields Requested fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createMergeQueryAsync($body = null, $fields = null)
    {
        return $this->createMergeQueryAsyncWithHttpInfo($body, $fields)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createMergeQueryAsyncWithHttpInfo
     *
     * Create Merge Query
     *
     * @param  \Swagger\Client\Model\MergeQuery $body Merge Query (optional)
     * @param  string $fields Requested fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createMergeQueryAsyncWithHttpInfo($body = null, $fields = null)
    {
        $returnType = '\Swagger\Client\Model\MergeQuery';
        $request = $this->createMergeQueryRequest($body, $fields);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createMergeQuery'
     *
     * @param  \Swagger\Client\Model\MergeQuery $body Merge Query (optional)
     * @param  string $fields Requested fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function createMergeQueryRequest($body = null, $fields = null)
    {

        $resourcePath = '/merge_queries';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($fields !== null) {
            $queryParams['fields'] = ObjectSerializer::toQueryValue($fields);
        }


        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createQuery
     *
     * Create Query
     *
     * @param  \Swagger\Client\Model\Query $body Query (optional)
     * @param  string $fields Requested fields. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\Query
     */
    public function createQuery($body = null, $fields = null)
    {
        list($response) = $this->createQueryWithHttpInfo($body, $fields);
        return $response;
    }

    /**
     * Operation createQueryWithHttpInfo
     *
     * Create Query
     *
     * @param  \Swagger\Client\Model\Query $body Query (optional)
     * @param  string $fields Requested fields. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\Query, HTTP status code, HTTP response headers (array of strings)
     */
    public function createQueryWithHttpInfo($body = null, $fields = null)
    {
        $returnType = '\Swagger\Client\Model\Query';
        $request = $this->createQueryRequest($body, $fields);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Query',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 409:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ValidationError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createQueryAsync
     *
     * Create Query
     *
     * @param  \Swagger\Client\Model\Query $body Query (optional)
     * @param  string $fields Requested fields. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createQueryAsync($body = null, $fields = null)
    {
        return $this->createQueryAsyncWithHttpInfo($body, $fields)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createQueryAsyncWithHttpInfo
     *
     * Create Query
     *
     * @param  \Swagger\Client\Model\Query $body Query (optional)
     * @param  string $fields Requested fields. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createQueryAsyncWithHttpInfo($body = null, $fields = null)
    {
        $returnType = '\Swagger\Client\Model\Query';
        $request = $this->createQueryRequest($body, $fields);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createQuery'
     *
     * @param  \Swagger\Client\Model\Query $body Query (optional)
     * @param  string $fields Requested fields. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function createQueryRequest($body = null, $fields = null)
    {

        $resourcePath = '/queries';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($fields !== null) {
            $queryParams['fields'] = ObjectSerializer::toQueryValue($fields);
        }


        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createQueryTask
     *
     * Run Query Async
     *
     * @param  \Swagger\Client\Model\CreateQueryTask $body Query parameters (required)
     * @param  int $limit Row limit (may override the limit in the saved query). (optional)
     * @param  bool $apply_formatting Apply model-specified formatting to each result. (optional)
     * @param  bool $apply_vis Apply visualization options to results. (optional)
     * @param  bool $cache Get results from cache if available. (optional)
     * @param  int $image_width Render width for image formats. (optional)
     * @param  int $image_height Render height for image formats. (optional)
     * @param  bool $generate_drill_links Generate drill links (only applicable to &#39;json_detail&#39; format. (optional)
     * @param  bool $force_production Force use of production models even if the user is in development mode. (optional)
     * @param  bool $cache_only Retrieve any results from cache even if the results have expired. (optional)
     * @param  string $path_prefix Prefix to use for drill links (url encoded). (optional)
     * @param  bool $rebuild_pdts Rebuild PDTS used in query. (optional)
     * @param  bool $server_table_calcs Perform table calculations on query results (optional)
     * @param  string $fields Requested fields (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\QueryTask
     */
    public function createQueryTask($body, $limit = null, $apply_formatting = null, $apply_vis = null, $cache = null, $image_width = null, $image_height = null, $generate_drill_links = null, $force_production = null, $cache_only = null, $path_prefix = null, $rebuild_pdts = null, $server_table_calcs = null, $fields = null)
    {
        list($response) = $this->createQueryTaskWithHttpInfo($body, $limit, $apply_formatting, $apply_vis, $cache, $image_width, $image_height, $generate_drill_links, $force_production, $cache_only, $path_prefix, $rebuild_pdts, $server_table_calcs, $fields);
        return $response;
    }

    /**
     * Operation createQueryTaskWithHttpInfo
     *
     * Run Query Async
     *
     * @param  \Swagger\Client\Model\CreateQueryTask $body Query parameters (required)
     * @param  int $limit Row limit (may override the limit in the saved query). (optional)
     * @param  bool $apply_formatting Apply model-specified formatting to each result. (optional)
     * @param  bool $apply_vis Apply visualization options to results. (optional)
     * @param  bool $cache Get results from cache if available. (optional)
     * @param  int $image_width Render width for image formats. (optional)
     * @param  int $image_height Render height for image formats. (optional)
     * @param  bool $generate_drill_links Generate drill links (only applicable to &#39;json_detail&#39; format. (optional)
     * @param  bool $force_production Force use of production models even if the user is in development mode. (optional)
     * @param  bool $cache_only Retrieve any results from cache even if the results have expired. (optional)
     * @param  string $path_prefix Prefix to use for drill links (url encoded). (optional)
     * @param  bool $rebuild_pdts Rebuild PDTS used in query. (optional)
     * @param  bool $server_table_calcs Perform table calculations on query results (optional)
     * @param  string $fields Requested fields (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\QueryTask, HTTP status code, HTTP response headers (array of strings)
     */
    public function createQueryTaskWithHttpInfo($body, $limit = null, $apply_formatting = null, $apply_vis = null, $cache = null, $image_width = null, $image_height = null, $generate_drill_links = null, $force_production = null, $cache_only = null, $path_prefix = null, $rebuild_pdts = null, $server_table_calcs = null, $fields = null)
    {
        $returnType = '\Swagger\Client\Model\QueryTask';
        $request = $this->createQueryTaskRequest($body, $limit, $apply_formatting, $apply_vis, $cache, $image_width, $image_height, $generate_drill_links, $force_production, $cache_only, $path_prefix, $rebuild_pdts, $server_table_calcs, $fields);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\QueryTask',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 409:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ValidationError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createQueryTaskAsync
     *
     * Run Query Async
     *
     * @param  \Swagger\Client\Model\CreateQueryTask $body Query parameters (required)
     * @param  int $limit Row limit (may override the limit in the saved query). (optional)
     * @param  bool $apply_formatting Apply model-specified formatting to each result. (optional)
     * @param  bool $apply_vis Apply visualization options to results. (optional)
     * @param  bool $cache Get results from cache if available. (optional)
     * @param  int $image_width Render width for image formats. (optional)
     * @param  int $image_height Render height for image formats. (optional)
     * @param  bool $generate_drill_links Generate drill links (only applicable to &#39;json_detail&#39; format. (optional)
     * @param  bool $force_production Force use of production models even if the user is in development mode. (optional)
     * @param  bool $cache_only Retrieve any results from cache even if the results have expired. (optional)
     * @param  string $path_prefix Prefix to use for drill links (url encoded). (optional)
     * @param  bool $rebuild_pdts Rebuild PDTS used in query. (optional)
     * @param  bool $server_table_calcs Perform table calculations on query results (optional)
     * @param  string $fields Requested fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createQueryTaskAsync($body, $limit = null, $apply_formatting = null, $apply_vis = null, $cache = null, $image_width = null, $image_height = null, $generate_drill_links = null, $force_production = null, $cache_only = null, $path_prefix = null, $rebuild_pdts = null, $server_table_calcs = null, $fields = null)
    {
        return $this->createQueryTaskAsyncWithHttpInfo($body, $limit, $apply_formatting, $apply_vis, $cache, $image_width, $image_height, $generate_drill_links, $force_production, $cache_only, $path_prefix, $rebuild_pdts, $server_table_calcs, $fields)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createQueryTaskAsyncWithHttpInfo
     *
     * Run Query Async
     *
     * @param  \Swagger\Client\Model\CreateQueryTask $body Query parameters (required)
     * @param  int $limit Row limit (may override the limit in the saved query). (optional)
     * @param  bool $apply_formatting Apply model-specified formatting to each result. (optional)
     * @param  bool $apply_vis Apply visualization options to results. (optional)
     * @param  bool $cache Get results from cache if available. (optional)
     * @param  int $image_width Render width for image formats. (optional)
     * @param  int $image_height Render height for image formats. (optional)
     * @param  bool $generate_drill_links Generate drill links (only applicable to &#39;json_detail&#39; format. (optional)
     * @param  bool $force_production Force use of production models even if the user is in development mode. (optional)
     * @param  bool $cache_only Retrieve any results from cache even if the results have expired. (optional)
     * @param  string $path_prefix Prefix to use for drill links (url encoded). (optional)
     * @param  bool $rebuild_pdts Rebuild PDTS used in query. (optional)
     * @param  bool $server_table_calcs Perform table calculations on query results (optional)
     * @param  string $fields Requested fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createQueryTaskAsyncWithHttpInfo($body, $limit = null, $apply_formatting = null, $apply_vis = null, $cache = null, $image_width = null, $image_height = null, $generate_drill_links = null, $force_production = null, $cache_only = null, $path_prefix = null, $rebuild_pdts = null, $server_table_calcs = null, $fields = null)
    {
        $returnType = '\Swagger\Client\Model\QueryTask';
        $request = $this->createQueryTaskRequest($body, $limit, $apply_formatting, $apply_vis, $cache, $image_width, $image_height, $generate_drill_links, $force_production, $cache_only, $path_prefix, $rebuild_pdts, $server_table_calcs, $fields);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createQueryTask'
     *
     * @param  \Swagger\Client\Model\CreateQueryTask $body Query parameters (required)
     * @param  int $limit Row limit (may override the limit in the saved query). (optional)
     * @param  bool $apply_formatting Apply model-specified formatting to each result. (optional)
     * @param  bool $apply_vis Apply visualization options to results. (optional)
     * @param  bool $cache Get results from cache if available. (optional)
     * @param  int $image_width Render width for image formats. (optional)
     * @param  int $image_height Render height for image formats. (optional)
     * @param  bool $generate_drill_links Generate drill links (only applicable to &#39;json_detail&#39; format. (optional)
     * @param  bool $force_production Force use of production models even if the user is in development mode. (optional)
     * @param  bool $cache_only Retrieve any results from cache even if the results have expired. (optional)
     * @param  string $path_prefix Prefix to use for drill links (url encoded). (optional)
     * @param  bool $rebuild_pdts Rebuild PDTS used in query. (optional)
     * @param  bool $server_table_calcs Perform table calculations on query results (optional)
     * @param  string $fields Requested fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function createQueryTaskRequest($body, $limit = null, $apply_formatting = null, $apply_vis = null, $cache = null, $image_width = null, $image_height = null, $generate_drill_links = null, $force_production = null, $cache_only = null, $path_prefix = null, $rebuild_pdts = null, $server_table_calcs = null, $fields = null)
    {
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling createQueryTask'
            );
        }

        $resourcePath = '/query_tasks';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($limit !== null) {
            $queryParams['limit'] = ObjectSerializer::toQueryValue($limit);
        }
        // query params
        if ($apply_formatting !== null) {
            $queryParams['apply_formatting'] = ObjectSerializer::toQueryValue($apply_formatting);
        }
        // query params
        if ($apply_vis !== null) {
            $queryParams['apply_vis'] = ObjectSerializer::toQueryValue($apply_vis);
        }
        // query params
        if ($cache !== null) {
            $queryParams['cache'] = ObjectSerializer::toQueryValue($cache);
        }
        // query params
        if ($image_width !== null) {
            $queryParams['image_width'] = ObjectSerializer::toQueryValue($image_width);
        }
        // query params
        if ($image_height !== null) {
            $queryParams['image_height'] = ObjectSerializer::toQueryValue($image_height);
        }
        // query params
        if ($generate_drill_links !== null) {
            $queryParams['generate_drill_links'] = ObjectSerializer::toQueryValue($generate_drill_links);
        }
        // query params
        if ($force_production !== null) {
            $queryParams['force_production'] = ObjectSerializer::toQueryValue($force_production);
        }
        // query params
        if ($cache_only !== null) {
            $queryParams['cache_only'] = ObjectSerializer::toQueryValue($cache_only);
        }
        // query params
        if ($path_prefix !== null) {
            $queryParams['path_prefix'] = ObjectSerializer::toQueryValue($path_prefix);
        }
        // query params
        if ($rebuild_pdts !== null) {
            $queryParams['rebuild_pdts'] = ObjectSerializer::toQueryValue($rebuild_pdts);
        }
        // query params
        if ($server_table_calcs !== null) {
            $queryParams['server_table_calcs'] = ObjectSerializer::toQueryValue($server_table_calcs);
        }
        // query params
        if ($fields !== null) {
            $queryParams['fields'] = ObjectSerializer::toQueryValue($fields);
        }


        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createSqlQuery
     *
     * Create SQL Runner Query
     *
     * @param  \Swagger\Client\Model\SqlQueryCreate $body SQL Runner Query (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\SqlQuery
     */
    public function createSqlQuery($body)
    {
        list($response) = $this->createSqlQueryWithHttpInfo($body);
        return $response;
    }

    /**
     * Operation createSqlQueryWithHttpInfo
     *
     * Create SQL Runner Query
     *
     * @param  \Swagger\Client\Model\SqlQueryCreate $body SQL Runner Query (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\SqlQuery, HTTP status code, HTTP response headers (array of strings)
     */
    public function createSqlQueryWithHttpInfo($body)
    {
        $returnType = '\Swagger\Client\Model\SqlQuery';
        $request = $this->createSqlQueryRequest($body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\SqlQuery',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 409:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ValidationError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createSqlQueryAsync
     *
     * Create SQL Runner Query
     *
     * @param  \Swagger\Client\Model\SqlQueryCreate $body SQL Runner Query (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createSqlQueryAsync($body)
    {
        return $this->createSqlQueryAsyncWithHttpInfo($body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createSqlQueryAsyncWithHttpInfo
     *
     * Create SQL Runner Query
     *
     * @param  \Swagger\Client\Model\SqlQueryCreate $body SQL Runner Query (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createSqlQueryAsyncWithHttpInfo($body)
    {
        $returnType = '\Swagger\Client\Model\SqlQuery';
        $request = $this->createSqlQueryRequest($body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createSqlQuery'
     *
     * @param  \Swagger\Client\Model\SqlQueryCreate $body SQL Runner Query (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function createSqlQueryRequest($body)
    {
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling createSqlQuery'
            );
        }

        $resourcePath = '/sql_queries';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation killQuery
     *
     * Kill Running Query
     *
     * @param  string $query_task_id Query task id. (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function killQuery($query_task_id)
    {
        list($response) = $this->killQueryWithHttpInfo($query_task_id);
        return $response;
    }

    /**
     * Operation killQueryWithHttpInfo
     *
     * Kill Running Query
     *
     * @param  string $query_task_id Query task id. (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function killQueryWithHttpInfo($query_task_id)
    {
        $returnType = 'string';
        $request = $this->killQueryRequest($query_task_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 204:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ValidationError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation killQueryAsync
     *
     * Kill Running Query
     *
     * @param  string $query_task_id Query task id. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function killQueryAsync($query_task_id)
    {
        return $this->killQueryAsyncWithHttpInfo($query_task_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation killQueryAsyncWithHttpInfo
     *
     * Kill Running Query
     *
     * @param  string $query_task_id Query task id. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function killQueryAsyncWithHttpInfo($query_task_id)
    {
        $returnType = 'string';
        $request = $this->killQueryRequest($query_task_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'killQuery'
     *
     * @param  string $query_task_id Query task id. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function killQueryRequest($query_task_id)
    {
        // verify the required parameter 'query_task_id' is set
        if ($query_task_id === null || (is_array($query_task_id) && count($query_task_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $query_task_id when calling killQuery'
            );
        }

        $resourcePath = '/running_queries/{query_task_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($query_task_id !== null) {
            $resourcePath = str_replace(
                '{' . 'query_task_id' . '}',
                ObjectSerializer::toPathValue($query_task_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation mergeQuery
     *
     * Get Merge Query
     *
     * @param  string $merge_query_id Merge Query Id (required)
     * @param  string $fields Requested fields (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\MergeQuery
     */
    public function mergeQuery($merge_query_id, $fields = null)
    {
        list($response) = $this->mergeQueryWithHttpInfo($merge_query_id, $fields);
        return $response;
    }

    /**
     * Operation mergeQueryWithHttpInfo
     *
     * Get Merge Query
     *
     * @param  string $merge_query_id Merge Query Id (required)
     * @param  string $fields Requested fields (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\MergeQuery, HTTP status code, HTTP response headers (array of strings)
     */
    public function mergeQueryWithHttpInfo($merge_query_id, $fields = null)
    {
        $returnType = '\Swagger\Client\Model\MergeQuery';
        $request = $this->mergeQueryRequest($merge_query_id, $fields);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\MergeQuery',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation mergeQueryAsync
     *
     * Get Merge Query
     *
     * @param  string $merge_query_id Merge Query Id (required)
     * @param  string $fields Requested fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function mergeQueryAsync($merge_query_id, $fields = null)
    {
        return $this->mergeQueryAsyncWithHttpInfo($merge_query_id, $fields)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation mergeQueryAsyncWithHttpInfo
     *
     * Get Merge Query
     *
     * @param  string $merge_query_id Merge Query Id (required)
     * @param  string $fields Requested fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function mergeQueryAsyncWithHttpInfo($merge_query_id, $fields = null)
    {
        $returnType = '\Swagger\Client\Model\MergeQuery';
        $request = $this->mergeQueryRequest($merge_query_id, $fields);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'mergeQuery'
     *
     * @param  string $merge_query_id Merge Query Id (required)
     * @param  string $fields Requested fields (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function mergeQueryRequest($merge_query_id, $fields = null)
    {
        // verify the required parameter 'merge_query_id' is set
        if ($merge_query_id === null || (is_array($merge_query_id) && count($merge_query_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $merge_query_id when calling mergeQuery'
            );
        }

        $resourcePath = '/merge_queries/{merge_query_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($fields !== null) {
            $queryParams['fields'] = ObjectSerializer::toQueryValue($fields);
        }

        // path params
        if ($merge_query_id !== null) {
            $resourcePath = str_replace(
                '{' . 'merge_query_id' . '}',
                ObjectSerializer::toPathValue($merge_query_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation query
     *
     * Get Query
     *
     * @param  int $query_id Id of query (required)
     * @param  string $fields Requested fields. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\Query
     */
    public function query($query_id, $fields = null)
    {
        list($response) = $this->queryWithHttpInfo($query_id, $fields);
        return $response;
    }

    /**
     * Operation queryWithHttpInfo
     *
     * Get Query
     *
     * @param  int $query_id Id of query (required)
     * @param  string $fields Requested fields. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\Query, HTTP status code, HTTP response headers (array of strings)
     */
    public function queryWithHttpInfo($query_id, $fields = null)
    {
        $returnType = '\Swagger\Client\Model\Query';
        $request = $this->queryRequest($query_id, $fields);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Query',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation queryAsync
     *
     * Get Query
     *
     * @param  int $query_id Id of query (required)
     * @param  string $fields Requested fields. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function queryAsync($query_id, $fields = null)
    {
        return $this->queryAsyncWithHttpInfo($query_id, $fields)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation queryAsyncWithHttpInfo
     *
     * Get Query
     *
     * @param  int $query_id Id of query (required)
     * @param  string $fields Requested fields. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function queryAsyncWithHttpInfo($query_id, $fields = null)
    {
        $returnType = '\Swagger\Client\Model\Query';
        $request = $this->queryRequest($query_id, $fields);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'query'
     *
     * @param  int $query_id Id of query (required)
     * @param  string $fields Requested fields. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function queryRequest($query_id, $fields = null)
    {
        // verify the required parameter 'query_id' is set
        if ($query_id === null || (is_array($query_id) && count($query_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $query_id when calling query'
            );
        }

        $resourcePath = '/queries/{query_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($fields !== null) {
            $queryParams['fields'] = ObjectSerializer::toQueryValue($fields);
        }

        // path params
        if ($query_id !== null) {
            $resourcePath = str_replace(
                '{' . 'query_id' . '}',
                ObjectSerializer::toPathValue($query_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation queryForSlug
     *
     * Get Query for Slug
     *
     * @param  string $slug Slug of query (required)
     * @param  string $fields Requested fields. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\Query
     */
    public function queryForSlug($slug, $fields = null)
    {
        list($response) = $this->queryForSlugWithHttpInfo($slug, $fields);
        return $response;
    }

    /**
     * Operation queryForSlugWithHttpInfo
     *
     * Get Query for Slug
     *
     * @param  string $slug Slug of query (required)
     * @param  string $fields Requested fields. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\Query, HTTP status code, HTTP response headers (array of strings)
     */
    public function queryForSlugWithHttpInfo($slug, $fields = null)
    {
        $returnType = '\Swagger\Client\Model\Query';
        $request = $this->queryForSlugRequest($slug, $fields);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Query',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation queryForSlugAsync
     *
     * Get Query for Slug
     *
     * @param  string $slug Slug of query (required)
     * @param  string $fields Requested fields. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function queryForSlugAsync($slug, $fields = null)
    {
        return $this->queryForSlugAsyncWithHttpInfo($slug, $fields)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation queryForSlugAsyncWithHttpInfo
     *
     * Get Query for Slug
     *
     * @param  string $slug Slug of query (required)
     * @param  string $fields Requested fields. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function queryForSlugAsyncWithHttpInfo($slug, $fields = null)
    {
        $returnType = '\Swagger\Client\Model\Query';
        $request = $this->queryForSlugRequest($slug, $fields);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'queryForSlug'
     *
     * @param  string $slug Slug of query (required)
     * @param  string $fields Requested fields. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function queryForSlugRequest($slug, $fields = null)
    {
        // verify the required parameter 'slug' is set
        if ($slug === null || (is_array($slug) && count($slug) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $slug when calling queryForSlug'
            );
        }

        $resourcePath = '/queries/slug/{slug}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($fields !== null) {
            $queryParams['fields'] = ObjectSerializer::toQueryValue($fields);
        }

        // path params
        if ($slug !== null) {
            $resourcePath = str_replace(
                '{' . 'slug' . '}',
                ObjectSerializer::toPathValue($slug),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation queryTask
     *
     * Get Async Query Info
     *
     * @param  string $query_task_id ID of the Query Task (required)
     * @param  string $fields Requested fields. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\QueryTask
     */
    public function queryTask($query_task_id, $fields = null)
    {
        list($response) = $this->queryTaskWithHttpInfo($query_task_id, $fields);
        return $response;
    }

    /**
     * Operation queryTaskWithHttpInfo
     *
     * Get Async Query Info
     *
     * @param  string $query_task_id ID of the Query Task (required)
     * @param  string $fields Requested fields. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\QueryTask, HTTP status code, HTTP response headers (array of strings)
     */
    public function queryTaskWithHttpInfo($query_task_id, $fields = null)
    {
        $returnType = '\Swagger\Client\Model\QueryTask';
        $request = $this->queryTaskRequest($query_task_id, $fields);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\QueryTask',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation queryTaskAsync
     *
     * Get Async Query Info
     *
     * @param  string $query_task_id ID of the Query Task (required)
     * @param  string $fields Requested fields. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function queryTaskAsync($query_task_id, $fields = null)
    {
        return $this->queryTaskAsyncWithHttpInfo($query_task_id, $fields)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation queryTaskAsyncWithHttpInfo
     *
     * Get Async Query Info
     *
     * @param  string $query_task_id ID of the Query Task (required)
     * @param  string $fields Requested fields. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function queryTaskAsyncWithHttpInfo($query_task_id, $fields = null)
    {
        $returnType = '\Swagger\Client\Model\QueryTask';
        $request = $this->queryTaskRequest($query_task_id, $fields);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'queryTask'
     *
     * @param  string $query_task_id ID of the Query Task (required)
     * @param  string $fields Requested fields. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function queryTaskRequest($query_task_id, $fields = null)
    {
        // verify the required parameter 'query_task_id' is set
        if ($query_task_id === null || (is_array($query_task_id) && count($query_task_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $query_task_id when calling queryTask'
            );
        }

        $resourcePath = '/query_tasks/{query_task_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($fields !== null) {
            $queryParams['fields'] = ObjectSerializer::toQueryValue($fields);
        }

        // path params
        if ($query_task_id !== null) {
            $resourcePath = str_replace(
                '{' . 'query_task_id' . '}',
                ObjectSerializer::toPathValue($query_task_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation queryTaskMultiResults
     *
     * Get Multiple Async Query Results
     *
     * @param  string[] $query_task_ids List of Query Task IDs (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return map[string,string]
     */
    public function queryTaskMultiResults($query_task_ids)
    {
        list($response) = $this->queryTaskMultiResultsWithHttpInfo($query_task_ids);
        return $response;
    }

    /**
     * Operation queryTaskMultiResultsWithHttpInfo
     *
     * Get Multiple Async Query Results
     *
     * @param  string[] $query_task_ids List of Query Task IDs (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of map[string,string], HTTP status code, HTTP response headers (array of strings)
     */
    public function queryTaskMultiResultsWithHttpInfo($query_task_ids)
    {
        $returnType = 'map[string,string]';
        $request = $this->queryTaskMultiResultsRequest($query_task_ids);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'map[string,string]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation queryTaskMultiResultsAsync
     *
     * Get Multiple Async Query Results
     *
     * @param  string[] $query_task_ids List of Query Task IDs (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function queryTaskMultiResultsAsync($query_task_ids)
    {
        return $this->queryTaskMultiResultsAsyncWithHttpInfo($query_task_ids)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation queryTaskMultiResultsAsyncWithHttpInfo
     *
     * Get Multiple Async Query Results
     *
     * @param  string[] $query_task_ids List of Query Task IDs (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function queryTaskMultiResultsAsyncWithHttpInfo($query_task_ids)
    {
        $returnType = 'map[string,string]';
        $request = $this->queryTaskMultiResultsRequest($query_task_ids);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'queryTaskMultiResults'
     *
     * @param  string[] $query_task_ids List of Query Task IDs (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function queryTaskMultiResultsRequest($query_task_ids)
    {
        // verify the required parameter 'query_task_ids' is set
        if ($query_task_ids === null || (is_array($query_task_ids) && count($query_task_ids) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $query_task_ids when calling queryTaskMultiResults'
            );
        }

        $resourcePath = '/query_tasks/multi_results';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($query_task_ids)) {
            $query_task_ids = ObjectSerializer::serializeCollection($query_task_ids, 'csv', true);
        }
        if ($query_task_ids !== null) {
            $queryParams['query_task_ids'] = ObjectSerializer::toQueryValue($query_task_ids);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation queryTaskResults
     *
     * Get Async Query Results
     *
     * @param  string $query_task_id ID of the Query Task (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return map[string,string]
     */
    public function queryTaskResults($query_task_id)
    {
        list($response) = $this->queryTaskResultsWithHttpInfo($query_task_id);
        return $response;
    }

    /**
     * Operation queryTaskResultsWithHttpInfo
     *
     * Get Async Query Results
     *
     * @param  string $query_task_id ID of the Query Task (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of map[string,string], HTTP status code, HTTP response headers (array of strings)
     */
    public function queryTaskResultsWithHttpInfo($query_task_id)
    {
        $returnType = 'map[string,string]';
        $request = $this->queryTaskResultsRequest($query_task_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'map[string,string]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 204:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation queryTaskResultsAsync
     *
     * Get Async Query Results
     *
     * @param  string $query_task_id ID of the Query Task (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function queryTaskResultsAsync($query_task_id)
    {
        return $this->queryTaskResultsAsyncWithHttpInfo($query_task_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation queryTaskResultsAsyncWithHttpInfo
     *
     * Get Async Query Results
     *
     * @param  string $query_task_id ID of the Query Task (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function queryTaskResultsAsyncWithHttpInfo($query_task_id)
    {
        $returnType = 'map[string,string]';
        $request = $this->queryTaskResultsRequest($query_task_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'queryTaskResults'
     *
     * @param  string $query_task_id ID of the Query Task (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function queryTaskResultsRequest($query_task_id)
    {
        // verify the required parameter 'query_task_id' is set
        if ($query_task_id === null || (is_array($query_task_id) && count($query_task_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $query_task_id when calling queryTaskResults'
            );
        }

        $resourcePath = '/query_tasks/{query_task_id}/results';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($query_task_id !== null) {
            $resourcePath = str_replace(
                '{' . 'query_task_id' . '}',
                ObjectSerializer::toPathValue($query_task_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text', 'application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation runInlineQuery
     *
     * Run Inline Query
     *
     * @param  string $result_format Format of result (required)
     * @param  \Swagger\Client\Model\Query $body inline query (required)
     * @param  int $limit Row limit (may override the limit in the saved query). (optional)
     * @param  bool $apply_formatting Apply model-specified formatting to each result. (optional)
     * @param  bool $apply_vis Apply visualization options to results. (optional)
     * @param  bool $cache Get results from cache if available. (optional)
     * @param  int $image_width Render width for image formats. (optional)
     * @param  int $image_height Render height for image formats. (optional)
     * @param  bool $generate_drill_links Generate drill links (only applicable to &#39;json_detail&#39; format. (optional)
     * @param  bool $force_production Force use of production models even if the user is in development mode. (optional)
     * @param  bool $cache_only Retrieve any results from cache even if the results have expired. (optional)
     * @param  string $path_prefix Prefix to use for drill links (url encoded). (optional)
     * @param  bool $rebuild_pdts Rebuild PDTS used in query. (optional)
     * @param  bool $server_table_calcs Perform table calculations on query results (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function runInlineQuery($result_format, $body, $limit = null, $apply_formatting = null, $apply_vis = null, $cache = null, $image_width = null, $image_height = null, $generate_drill_links = null, $force_production = null, $cache_only = null, $path_prefix = null, $rebuild_pdts = null, $server_table_calcs = null)
    {
        list($response) = $this->runInlineQueryWithHttpInfo($result_format, $body, $limit, $apply_formatting, $apply_vis, $cache, $image_width, $image_height, $generate_drill_links, $force_production, $cache_only, $path_prefix, $rebuild_pdts, $server_table_calcs);
        return $response;
    }

    /**
     * Operation runInlineQueryWithHttpInfo
     *
     * Run Inline Query
     *
     * @param  string $result_format Format of result (required)
     * @param  \Swagger\Client\Model\Query $body inline query (required)
     * @param  int $limit Row limit (may override the limit in the saved query). (optional)
     * @param  bool $apply_formatting Apply model-specified formatting to each result. (optional)
     * @param  bool $apply_vis Apply visualization options to results. (optional)
     * @param  bool $cache Get results from cache if available. (optional)
     * @param  int $image_width Render width for image formats. (optional)
     * @param  int $image_height Render height for image formats. (optional)
     * @param  bool $generate_drill_links Generate drill links (only applicable to &#39;json_detail&#39; format. (optional)
     * @param  bool $force_production Force use of production models even if the user is in development mode. (optional)
     * @param  bool $cache_only Retrieve any results from cache even if the results have expired. (optional)
     * @param  string $path_prefix Prefix to use for drill links (url encoded). (optional)
     * @param  bool $rebuild_pdts Rebuild PDTS used in query. (optional)
     * @param  bool $server_table_calcs Perform table calculations on query results (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function runInlineQueryWithHttpInfo($result_format, $body, $limit = null, $apply_formatting = null, $apply_vis = null, $cache = null, $image_width = null, $image_height = null, $generate_drill_links = null, $force_production = null, $cache_only = null, $path_prefix = null, $rebuild_pdts = null, $server_table_calcs = null)
    {
        $returnType = 'string';
        $request = $this->runInlineQueryRequest($result_format, $body, $limit, $apply_formatting, $apply_vis, $cache, $image_width, $image_height, $generate_drill_links, $force_production, $cache_only, $path_prefix, $rebuild_pdts, $server_table_calcs);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation runInlineQueryAsync
     *
     * Run Inline Query
     *
     * @param  string $result_format Format of result (required)
     * @param  \Swagger\Client\Model\Query $body inline query (required)
     * @param  int $limit Row limit (may override the limit in the saved query). (optional)
     * @param  bool $apply_formatting Apply model-specified formatting to each result. (optional)
     * @param  bool $apply_vis Apply visualization options to results. (optional)
     * @param  bool $cache Get results from cache if available. (optional)
     * @param  int $image_width Render width for image formats. (optional)
     * @param  int $image_height Render height for image formats. (optional)
     * @param  bool $generate_drill_links Generate drill links (only applicable to &#39;json_detail&#39; format. (optional)
     * @param  bool $force_production Force use of production models even if the user is in development mode. (optional)
     * @param  bool $cache_only Retrieve any results from cache even if the results have expired. (optional)
     * @param  string $path_prefix Prefix to use for drill links (url encoded). (optional)
     * @param  bool $rebuild_pdts Rebuild PDTS used in query. (optional)
     * @param  bool $server_table_calcs Perform table calculations on query results (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function runInlineQueryAsync($result_format, $body, $limit = null, $apply_formatting = null, $apply_vis = null, $cache = null, $image_width = null, $image_height = null, $generate_drill_links = null, $force_production = null, $cache_only = null, $path_prefix = null, $rebuild_pdts = null, $server_table_calcs = null)
    {
        return $this->runInlineQueryAsyncWithHttpInfo($result_format, $body, $limit, $apply_formatting, $apply_vis, $cache, $image_width, $image_height, $generate_drill_links, $force_production, $cache_only, $path_prefix, $rebuild_pdts, $server_table_calcs)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation runInlineQueryAsyncWithHttpInfo
     *
     * Run Inline Query
     *
     * @param  string $result_format Format of result (required)
     * @param  \Swagger\Client\Model\Query $body inline query (required)
     * @param  int $limit Row limit (may override the limit in the saved query). (optional)
     * @param  bool $apply_formatting Apply model-specified formatting to each result. (optional)
     * @param  bool $apply_vis Apply visualization options to results. (optional)
     * @param  bool $cache Get results from cache if available. (optional)
     * @param  int $image_width Render width for image formats. (optional)
     * @param  int $image_height Render height for image formats. (optional)
     * @param  bool $generate_drill_links Generate drill links (only applicable to &#39;json_detail&#39; format. (optional)
     * @param  bool $force_production Force use of production models even if the user is in development mode. (optional)
     * @param  bool $cache_only Retrieve any results from cache even if the results have expired. (optional)
     * @param  string $path_prefix Prefix to use for drill links (url encoded). (optional)
     * @param  bool $rebuild_pdts Rebuild PDTS used in query. (optional)
     * @param  bool $server_table_calcs Perform table calculations on query results (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function runInlineQueryAsyncWithHttpInfo($result_format, $body, $limit = null, $apply_formatting = null, $apply_vis = null, $cache = null, $image_width = null, $image_height = null, $generate_drill_links = null, $force_production = null, $cache_only = null, $path_prefix = null, $rebuild_pdts = null, $server_table_calcs = null)
    {
        $returnType = 'string';
        $request = $this->runInlineQueryRequest($result_format, $body, $limit, $apply_formatting, $apply_vis, $cache, $image_width, $image_height, $generate_drill_links, $force_production, $cache_only, $path_prefix, $rebuild_pdts, $server_table_calcs);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'runInlineQuery'
     *
     * @param  string $result_format Format of result (required)
     * @param  \Swagger\Client\Model\Query $body inline query (required)
     * @param  int $limit Row limit (may override the limit in the saved query). (optional)
     * @param  bool $apply_formatting Apply model-specified formatting to each result. (optional)
     * @param  bool $apply_vis Apply visualization options to results. (optional)
     * @param  bool $cache Get results from cache if available. (optional)
     * @param  int $image_width Render width for image formats. (optional)
     * @param  int $image_height Render height for image formats. (optional)
     * @param  bool $generate_drill_links Generate drill links (only applicable to &#39;json_detail&#39; format. (optional)
     * @param  bool $force_production Force use of production models even if the user is in development mode. (optional)
     * @param  bool $cache_only Retrieve any results from cache even if the results have expired. (optional)
     * @param  string $path_prefix Prefix to use for drill links (url encoded). (optional)
     * @param  bool $rebuild_pdts Rebuild PDTS used in query. (optional)
     * @param  bool $server_table_calcs Perform table calculations on query results (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function runInlineQueryRequest($result_format, $body, $limit = null, $apply_formatting = null, $apply_vis = null, $cache = null, $image_width = null, $image_height = null, $generate_drill_links = null, $force_production = null, $cache_only = null, $path_prefix = null, $rebuild_pdts = null, $server_table_calcs = null)
    {
        // verify the required parameter 'result_format' is set
        if ($result_format === null || (is_array($result_format) && count($result_format) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $result_format when calling runInlineQuery'
            );
        }
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling runInlineQuery'
            );
        }

        $resourcePath = '/queries/run/{result_format}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($limit !== null) {
            $queryParams['limit'] = ObjectSerializer::toQueryValue($limit);
        }
        // query params
        if ($apply_formatting !== null) {
            $queryParams['apply_formatting'] = ObjectSerializer::toQueryValue($apply_formatting);
        }
        // query params
        if ($apply_vis !== null) {
            $queryParams['apply_vis'] = ObjectSerializer::toQueryValue($apply_vis);
        }
        // query params
        if ($cache !== null) {
            $queryParams['cache'] = ObjectSerializer::toQueryValue($cache);
        }
        // query params
        if ($image_width !== null) {
            $queryParams['image_width'] = ObjectSerializer::toQueryValue($image_width);
        }
        // query params
        if ($image_height !== null) {
            $queryParams['image_height'] = ObjectSerializer::toQueryValue($image_height);
        }
        // query params
        if ($generate_drill_links !== null) {
            $queryParams['generate_drill_links'] = ObjectSerializer::toQueryValue($generate_drill_links);
        }
        // query params
        if ($force_production !== null) {
            $queryParams['force_production'] = ObjectSerializer::toQueryValue($force_production);
        }
        // query params
        if ($cache_only !== null) {
            $queryParams['cache_only'] = ObjectSerializer::toQueryValue($cache_only);
        }
        // query params
        if ($path_prefix !== null) {
            $queryParams['path_prefix'] = ObjectSerializer::toQueryValue($path_prefix);
        }
        // query params
        if ($rebuild_pdts !== null) {
            $queryParams['rebuild_pdts'] = ObjectSerializer::toQueryValue($rebuild_pdts);
        }
        // query params
        if ($server_table_calcs !== null) {
            $queryParams['server_table_calcs'] = ObjectSerializer::toQueryValue($server_table_calcs);
        }

        // path params
        if ($result_format !== null) {
            $resourcePath = str_replace(
                '{' . 'result_format' . '}',
                ObjectSerializer::toPathValue($result_format),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text', 'application/json', 'image/png', 'image/jpg']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text', 'application/json', 'image/png', 'image/jpg'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation runQuery
     *
     * Run Query
     *
     * @param  int $query_id Id of query (required)
     * @param  string $result_format Format of result (required)
     * @param  int $limit Row limit (may override the limit in the saved query). (optional)
     * @param  bool $apply_formatting Apply model-specified formatting to each result. (optional)
     * @param  bool $apply_vis Apply visualization options to results. (optional)
     * @param  bool $cache Get results from cache if available. (optional)
     * @param  int $image_width Render width for image formats. (optional)
     * @param  int $image_height Render height for image formats. (optional)
     * @param  bool $generate_drill_links Generate drill links (only applicable to &#39;json_detail&#39; format. (optional)
     * @param  bool $force_production Force use of production models even if the user is in development mode. (optional)
     * @param  bool $cache_only Retrieve any results from cache even if the results have expired. (optional)
     * @param  string $path_prefix Prefix to use for drill links (url encoded). (optional)
     * @param  bool $rebuild_pdts Rebuild PDTS used in query. (optional)
     * @param  bool $server_table_calcs Perform table calculations on query results (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function runQuery($query_id, $result_format, $limit = null, $apply_formatting = null, $apply_vis = null, $cache = null, $image_width = null, $image_height = null, $generate_drill_links = null, $force_production = null, $cache_only = null, $path_prefix = null, $rebuild_pdts = null, $server_table_calcs = null)
    {
        list($response) = $this->runQueryWithHttpInfo($query_id, $result_format, $limit, $apply_formatting, $apply_vis, $cache, $image_width, $image_height, $generate_drill_links, $force_production, $cache_only, $path_prefix, $rebuild_pdts, $server_table_calcs);
        return $response;
    }

    /**
     * Operation runQueryWithHttpInfo
     *
     * Run Query
     *
     * @param  int $query_id Id of query (required)
     * @param  string $result_format Format of result (required)
     * @param  int $limit Row limit (may override the limit in the saved query). (optional)
     * @param  bool $apply_formatting Apply model-specified formatting to each result. (optional)
     * @param  bool $apply_vis Apply visualization options to results. (optional)
     * @param  bool $cache Get results from cache if available. (optional)
     * @param  int $image_width Render width for image formats. (optional)
     * @param  int $image_height Render height for image formats. (optional)
     * @param  bool $generate_drill_links Generate drill links (only applicable to &#39;json_detail&#39; format. (optional)
     * @param  bool $force_production Force use of production models even if the user is in development mode. (optional)
     * @param  bool $cache_only Retrieve any results from cache even if the results have expired. (optional)
     * @param  string $path_prefix Prefix to use for drill links (url encoded). (optional)
     * @param  bool $rebuild_pdts Rebuild PDTS used in query. (optional)
     * @param  bool $server_table_calcs Perform table calculations on query results (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function runQueryWithHttpInfo($query_id, $result_format, $limit = null, $apply_formatting = null, $apply_vis = null, $cache = null, $image_width = null, $image_height = null, $generate_drill_links = null, $force_production = null, $cache_only = null, $path_prefix = null, $rebuild_pdts = null, $server_table_calcs = null)
    {
        $returnType = 'string';
        $request = $this->runQueryRequest($query_id, $result_format, $limit, $apply_formatting, $apply_vis, $cache, $image_width, $image_height, $generate_drill_links, $force_production, $cache_only, $path_prefix, $rebuild_pdts, $server_table_calcs);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ValidationError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation runQueryAsync
     *
     * Run Query
     *
     * @param  int $query_id Id of query (required)
     * @param  string $result_format Format of result (required)
     * @param  int $limit Row limit (may override the limit in the saved query). (optional)
     * @param  bool $apply_formatting Apply model-specified formatting to each result. (optional)
     * @param  bool $apply_vis Apply visualization options to results. (optional)
     * @param  bool $cache Get results from cache if available. (optional)
     * @param  int $image_width Render width for image formats. (optional)
     * @param  int $image_height Render height for image formats. (optional)
     * @param  bool $generate_drill_links Generate drill links (only applicable to &#39;json_detail&#39; format. (optional)
     * @param  bool $force_production Force use of production models even if the user is in development mode. (optional)
     * @param  bool $cache_only Retrieve any results from cache even if the results have expired. (optional)
     * @param  string $path_prefix Prefix to use for drill links (url encoded). (optional)
     * @param  bool $rebuild_pdts Rebuild PDTS used in query. (optional)
     * @param  bool $server_table_calcs Perform table calculations on query results (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function runQueryAsync($query_id, $result_format, $limit = null, $apply_formatting = null, $apply_vis = null, $cache = null, $image_width = null, $image_height = null, $generate_drill_links = null, $force_production = null, $cache_only = null, $path_prefix = null, $rebuild_pdts = null, $server_table_calcs = null)
    {
        return $this->runQueryAsyncWithHttpInfo($query_id, $result_format, $limit, $apply_formatting, $apply_vis, $cache, $image_width, $image_height, $generate_drill_links, $force_production, $cache_only, $path_prefix, $rebuild_pdts, $server_table_calcs)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation runQueryAsyncWithHttpInfo
     *
     * Run Query
     *
     * @param  int $query_id Id of query (required)
     * @param  string $result_format Format of result (required)
     * @param  int $limit Row limit (may override the limit in the saved query). (optional)
     * @param  bool $apply_formatting Apply model-specified formatting to each result. (optional)
     * @param  bool $apply_vis Apply visualization options to results. (optional)
     * @param  bool $cache Get results from cache if available. (optional)
     * @param  int $image_width Render width for image formats. (optional)
     * @param  int $image_height Render height for image formats. (optional)
     * @param  bool $generate_drill_links Generate drill links (only applicable to &#39;json_detail&#39; format. (optional)
     * @param  bool $force_production Force use of production models even if the user is in development mode. (optional)
     * @param  bool $cache_only Retrieve any results from cache even if the results have expired. (optional)
     * @param  string $path_prefix Prefix to use for drill links (url encoded). (optional)
     * @param  bool $rebuild_pdts Rebuild PDTS used in query. (optional)
     * @param  bool $server_table_calcs Perform table calculations on query results (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function runQueryAsyncWithHttpInfo($query_id, $result_format, $limit = null, $apply_formatting = null, $apply_vis = null, $cache = null, $image_width = null, $image_height = null, $generate_drill_links = null, $force_production = null, $cache_only = null, $path_prefix = null, $rebuild_pdts = null, $server_table_calcs = null)
    {
        $returnType = 'string';
        $request = $this->runQueryRequest($query_id, $result_format, $limit, $apply_formatting, $apply_vis, $cache, $image_width, $image_height, $generate_drill_links, $force_production, $cache_only, $path_prefix, $rebuild_pdts, $server_table_calcs);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'runQuery'
     *
     * @param  int $query_id Id of query (required)
     * @param  string $result_format Format of result (required)
     * @param  int $limit Row limit (may override the limit in the saved query). (optional)
     * @param  bool $apply_formatting Apply model-specified formatting to each result. (optional)
     * @param  bool $apply_vis Apply visualization options to results. (optional)
     * @param  bool $cache Get results from cache if available. (optional)
     * @param  int $image_width Render width for image formats. (optional)
     * @param  int $image_height Render height for image formats. (optional)
     * @param  bool $generate_drill_links Generate drill links (only applicable to &#39;json_detail&#39; format. (optional)
     * @param  bool $force_production Force use of production models even if the user is in development mode. (optional)
     * @param  bool $cache_only Retrieve any results from cache even if the results have expired. (optional)
     * @param  string $path_prefix Prefix to use for drill links (url encoded). (optional)
     * @param  bool $rebuild_pdts Rebuild PDTS used in query. (optional)
     * @param  bool $server_table_calcs Perform table calculations on query results (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function runQueryRequest($query_id, $result_format, $limit = null, $apply_formatting = null, $apply_vis = null, $cache = null, $image_width = null, $image_height = null, $generate_drill_links = null, $force_production = null, $cache_only = null, $path_prefix = null, $rebuild_pdts = null, $server_table_calcs = null)
    {
        // verify the required parameter 'query_id' is set
        if ($query_id === null || (is_array($query_id) && count($query_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $query_id when calling runQuery'
            );
        }
        // verify the required parameter 'result_format' is set
        if ($result_format === null || (is_array($result_format) && count($result_format) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $result_format when calling runQuery'
            );
        }

        $resourcePath = '/queries/{query_id}/run/{result_format}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($limit !== null) {
            $queryParams['limit'] = ObjectSerializer::toQueryValue($limit);
        }
        // query params
        if ($apply_formatting !== null) {
            $queryParams['apply_formatting'] = ObjectSerializer::toQueryValue($apply_formatting);
        }
        // query params
        if ($apply_vis !== null) {
            $queryParams['apply_vis'] = ObjectSerializer::toQueryValue($apply_vis);
        }
        // query params
        if ($cache !== null) {
            $queryParams['cache'] = ObjectSerializer::toQueryValue($cache);
        }
        // query params
        if ($image_width !== null) {
            $queryParams['image_width'] = ObjectSerializer::toQueryValue($image_width);
        }
        // query params
        if ($image_height !== null) {
            $queryParams['image_height'] = ObjectSerializer::toQueryValue($image_height);
        }
        // query params
        if ($generate_drill_links !== null) {
            $queryParams['generate_drill_links'] = ObjectSerializer::toQueryValue($generate_drill_links);
        }
        // query params
        if ($force_production !== null) {
            $queryParams['force_production'] = ObjectSerializer::toQueryValue($force_production);
        }
        // query params
        if ($cache_only !== null) {
            $queryParams['cache_only'] = ObjectSerializer::toQueryValue($cache_only);
        }
        // query params
        if ($path_prefix !== null) {
            $queryParams['path_prefix'] = ObjectSerializer::toQueryValue($path_prefix);
        }
        // query params
        if ($rebuild_pdts !== null) {
            $queryParams['rebuild_pdts'] = ObjectSerializer::toQueryValue($rebuild_pdts);
        }
        // query params
        if ($server_table_calcs !== null) {
            $queryParams['server_table_calcs'] = ObjectSerializer::toQueryValue($server_table_calcs);
        }

        // path params
        if ($query_id !== null) {
            $resourcePath = str_replace(
                '{' . 'query_id' . '}',
                ObjectSerializer::toPathValue($query_id),
                $resourcePath
            );
        }
        // path params
        if ($result_format !== null) {
            $resourcePath = str_replace(
                '{' . 'result_format' . '}',
                ObjectSerializer::toPathValue($result_format),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text', 'application/json', 'image/png', 'image/jpg']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text', 'application/json', 'image/png', 'image/jpg'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation runSqlQuery
     *
     * Run SQL Runner Query
     *
     * @param  string $slug slug of query (required)
     * @param  string $result_format Format of result, options are: [\&quot;json\&quot;, \&quot;json_detail\&quot;, \&quot;json_fe\&quot;, \&quot;csv\&quot;, \&quot;html\&quot;, \&quot;md\&quot;, \&quot;txt\&quot;, \&quot;xlsx\&quot;, \&quot;gsxml\&quot;] (required)
     * @param  string $download Defaults to false. If set to true, the HTTP response will have content-disposition and other headers set to make the HTTP response behave as a downloadable attachment instead of as inline content. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function runSqlQuery($slug, $result_format, $download = null)
    {
        list($response) = $this->runSqlQueryWithHttpInfo($slug, $result_format, $download);
        return $response;
    }

    /**
     * Operation runSqlQueryWithHttpInfo
     *
     * Run SQL Runner Query
     *
     * @param  string $slug slug of query (required)
     * @param  string $result_format Format of result, options are: [\&quot;json\&quot;, \&quot;json_detail\&quot;, \&quot;json_fe\&quot;, \&quot;csv\&quot;, \&quot;html\&quot;, \&quot;md\&quot;, \&quot;txt\&quot;, \&quot;xlsx\&quot;, \&quot;gsxml\&quot;] (required)
     * @param  string $download Defaults to false. If set to true, the HTTP response will have content-disposition and other headers set to make the HTTP response behave as a downloadable attachment instead of as inline content. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function runSqlQueryWithHttpInfo($slug, $result_format, $download = null)
    {
        $returnType = 'string';
        $request = $this->runSqlQueryRequest($slug, $result_format, $download);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ValidationError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation runSqlQueryAsync
     *
     * Run SQL Runner Query
     *
     * @param  string $slug slug of query (required)
     * @param  string $result_format Format of result, options are: [\&quot;json\&quot;, \&quot;json_detail\&quot;, \&quot;json_fe\&quot;, \&quot;csv\&quot;, \&quot;html\&quot;, \&quot;md\&quot;, \&quot;txt\&quot;, \&quot;xlsx\&quot;, \&quot;gsxml\&quot;] (required)
     * @param  string $download Defaults to false. If set to true, the HTTP response will have content-disposition and other headers set to make the HTTP response behave as a downloadable attachment instead of as inline content. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function runSqlQueryAsync($slug, $result_format, $download = null)
    {
        return $this->runSqlQueryAsyncWithHttpInfo($slug, $result_format, $download)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation runSqlQueryAsyncWithHttpInfo
     *
     * Run SQL Runner Query
     *
     * @param  string $slug slug of query (required)
     * @param  string $result_format Format of result, options are: [\&quot;json\&quot;, \&quot;json_detail\&quot;, \&quot;json_fe\&quot;, \&quot;csv\&quot;, \&quot;html\&quot;, \&quot;md\&quot;, \&quot;txt\&quot;, \&quot;xlsx\&quot;, \&quot;gsxml\&quot;] (required)
     * @param  string $download Defaults to false. If set to true, the HTTP response will have content-disposition and other headers set to make the HTTP response behave as a downloadable attachment instead of as inline content. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function runSqlQueryAsyncWithHttpInfo($slug, $result_format, $download = null)
    {
        $returnType = 'string';
        $request = $this->runSqlQueryRequest($slug, $result_format, $download);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'runSqlQuery'
     *
     * @param  string $slug slug of query (required)
     * @param  string $result_format Format of result, options are: [\&quot;json\&quot;, \&quot;json_detail\&quot;, \&quot;json_fe\&quot;, \&quot;csv\&quot;, \&quot;html\&quot;, \&quot;md\&quot;, \&quot;txt\&quot;, \&quot;xlsx\&quot;, \&quot;gsxml\&quot;] (required)
     * @param  string $download Defaults to false. If set to true, the HTTP response will have content-disposition and other headers set to make the HTTP response behave as a downloadable attachment instead of as inline content. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function runSqlQueryRequest($slug, $result_format, $download = null)
    {
        // verify the required parameter 'slug' is set
        if ($slug === null || (is_array($slug) && count($slug) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $slug when calling runSqlQuery'
            );
        }
        // verify the required parameter 'result_format' is set
        if ($result_format === null || (is_array($result_format) && count($result_format) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $result_format when calling runSqlQuery'
            );
        }

        $resourcePath = '/sql_queries/{slug}/run/{result_format}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($download !== null) {
            $queryParams['download'] = ObjectSerializer::toQueryValue($download);
        }

        // path params
        if ($slug !== null) {
            $resourcePath = str_replace(
                '{' . 'slug' . '}',
                ObjectSerializer::toPathValue($slug),
                $resourcePath
            );
        }
        // path params
        if ($result_format !== null) {
            $resourcePath = str_replace(
                '{' . 'result_format' . '}',
                ObjectSerializer::toPathValue($result_format),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text', 'application/json', 'image/png', 'image/jpg']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text', 'application/json', 'image/png', 'image/jpg'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation runUrlEncodedQuery
     *
     * Run Url Encoded Query
     *
     * @param  string $model_name Model name (required)
     * @param  string $view_name View name (required)
     * @param  string $result_format Format of result (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return string
     */
    public function runUrlEncodedQuery($model_name, $view_name, $result_format)
    {
        list($response) = $this->runUrlEncodedQueryWithHttpInfo($model_name, $view_name, $result_format);
        return $response;
    }

    /**
     * Operation runUrlEncodedQueryWithHttpInfo
     *
     * Run Url Encoded Query
     *
     * @param  string $model_name Model name (required)
     * @param  string $view_name View name (required)
     * @param  string $result_format Format of result (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function runUrlEncodedQueryWithHttpInfo($model_name, $view_name, $result_format)
    {
        $returnType = 'string';
        $request = $this->runUrlEncodedQueryRequest($model_name, $view_name, $result_format);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ValidationError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation runUrlEncodedQueryAsync
     *
     * Run Url Encoded Query
     *
     * @param  string $model_name Model name (required)
     * @param  string $view_name View name (required)
     * @param  string $result_format Format of result (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function runUrlEncodedQueryAsync($model_name, $view_name, $result_format)
    {
        return $this->runUrlEncodedQueryAsyncWithHttpInfo($model_name, $view_name, $result_format)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation runUrlEncodedQueryAsyncWithHttpInfo
     *
     * Run Url Encoded Query
     *
     * @param  string $model_name Model name (required)
     * @param  string $view_name View name (required)
     * @param  string $result_format Format of result (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function runUrlEncodedQueryAsyncWithHttpInfo($model_name, $view_name, $result_format)
    {
        $returnType = 'string';
        $request = $this->runUrlEncodedQueryRequest($model_name, $view_name, $result_format);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'runUrlEncodedQuery'
     *
     * @param  string $model_name Model name (required)
     * @param  string $view_name View name (required)
     * @param  string $result_format Format of result (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function runUrlEncodedQueryRequest($model_name, $view_name, $result_format)
    {
        // verify the required parameter 'model_name' is set
        if ($model_name === null || (is_array($model_name) && count($model_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $model_name when calling runUrlEncodedQuery'
            );
        }
        // verify the required parameter 'view_name' is set
        if ($view_name === null || (is_array($view_name) && count($view_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $view_name when calling runUrlEncodedQuery'
            );
        }
        // verify the required parameter 'result_format' is set
        if ($result_format === null || (is_array($result_format) && count($result_format) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $result_format when calling runUrlEncodedQuery'
            );
        }

        $resourcePath = '/queries/models/{model_name}/views/{view_name}/run/{result_format}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($model_name !== null) {
            $resourcePath = str_replace(
                '{' . 'model_name' . '}',
                ObjectSerializer::toPathValue($model_name),
                $resourcePath
            );
        }
        // path params
        if ($view_name !== null) {
            $resourcePath = str_replace(
                '{' . 'view_name' . '}',
                ObjectSerializer::toPathValue($view_name),
                $resourcePath
            );
        }
        // path params
        if ($result_format !== null) {
            $resourcePath = str_replace(
                '{' . 'result_format' . '}',
                ObjectSerializer::toPathValue($result_format),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text', 'application/json', 'image/png', 'image/jpg']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text', 'application/json', 'image/png', 'image/jpg'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation sqlQuery
     *
     * Get SQL Runner Query
     *
     * @param  string $slug slug of query (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\SqlQuery
     */
    public function sqlQuery($slug)
    {
        list($response) = $this->sqlQueryWithHttpInfo($slug);
        return $response;
    }

    /**
     * Operation sqlQueryWithHttpInfo
     *
     * Get SQL Runner Query
     *
     * @param  string $slug slug of query (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\SqlQuery, HTTP status code, HTTP response headers (array of strings)
     */
    public function sqlQueryWithHttpInfo($slug)
    {
        $returnType = '\Swagger\Client\Model\SqlQuery';
        $request = $this->sqlQueryRequest($slug);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\SqlQuery',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation sqlQueryAsync
     *
     * Get SQL Runner Query
     *
     * @param  string $slug slug of query (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function sqlQueryAsync($slug)
    {
        return $this->sqlQueryAsyncWithHttpInfo($slug)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation sqlQueryAsyncWithHttpInfo
     *
     * Get SQL Runner Query
     *
     * @param  string $slug slug of query (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function sqlQueryAsyncWithHttpInfo($slug)
    {
        $returnType = '\Swagger\Client\Model\SqlQuery';
        $request = $this->sqlQueryRequest($slug);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'sqlQuery'
     *
     * @param  string $slug slug of query (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function sqlQueryRequest($slug)
    {
        // verify the required parameter 'slug' is set
        if ($slug === null || (is_array($slug) && count($slug) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $slug when calling sqlQuery'
            );
        }

        $resourcePath = '/sql_queries/{slug}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($slug !== null) {
            $resourcePath = str_replace(
                '{' . 'slug' . '}',
                ObjectSerializer::toPathValue($slug),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
